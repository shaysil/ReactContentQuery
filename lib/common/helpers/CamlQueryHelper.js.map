{"version":3,"sources":["common/helpers/CamlQueryHelper.ts"],"names":[],"mappings":"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","file":"common/helpers/CamlQueryHelper.js","sourcesContent":["import * as moment                                              from 'moment';\nimport { Text }                                                 from '@microsoft/sp-core-library';\nimport { isEmpty }                                              from '@microsoft/sp-lodash-subset';\nimport { IPersonaProps, ITag }                                  from 'office-ui-fabric-react';\nimport { IQuerySettings }                                       from '../../webparts/contentQuery/components/IQuerySettings';\nimport { IQueryFilter }                                         from '../../controls/PropertyPaneQueryFilterPanel/components/QueryFilter/IQueryFilter';\nimport { QueryFilterOperator }                                  from '../../controls/PropertyPaneQueryFilterPanel/components/QueryFilter/QueryFilterOperator';\nimport { QueryFilterJoin }                                      from '../../controls/PropertyPaneQueryFilterPanel/components/QueryFilter/QueryFilterJoin';\nimport { QueryFilterFieldType }                                 from '../../controls/PropertyPaneQueryFilterPanel/components/QueryFilter/QueryFilterFieldType';\n\nexport class CamlQueryHelper {\n\n    /*************************************************************************************************\n     * Generates a full CAML query based on the provided IQuerySettings\n     * @param querySettings : A IQuerySettings object required for generating the CAML query\n     *************************************************************************************************/\n    public static generateCamlQuery(querySettings:IQuerySettings): string {\n        let query = '';\n\n        // Generates the <Where /> part\n        if(querySettings.filters && !isEmpty(querySettings.filters)) {\n            let sortedFilters = querySettings.filters.sort((a, b) => { return a.index - b.index; });\n            query += Text.format('<Where>{0}</Where>', this.generateFilters(sortedFilters));\n        }\n\n        // Generates the <OrderBy /> part\n        if(querySettings.orderBy && !isEmpty(querySettings.orderBy)) {\n            let isAscending = querySettings.orderByDirection == 'desc' ? 'FALSE' : 'TRUE';\n            query += Text.format(\"<OrderBy><FieldRef Name='{0}' Ascending='{1}' /></OrderBy>\", querySettings.orderBy, isAscending);\n        }\n\n        // Wraps the <Where /> and <OrderBy /> into a <Query /> tag\n        query = Text.format('<Query>{0}</Query>', query);\n\n        // Generates the <RowLimit /> part\n        if(querySettings.limitEnabled) {\n            query += Text.format('<RowLimit>{0}</RowLimit>', querySettings.itemLimit);\n        }\n\n        // Generates the <ViewFields /> part\n        if(querySettings.viewFields && !isEmpty(querySettings.viewFields)) {\n            query += Text.format('<ViewFields>{0}</ViewFields>', querySettings.viewFields.map(field => Text.format(\"<FieldRef Name='{0}' />\", field)).join(''));\n        }\n\n        // Wraps the everything into a final <View /> tag\n        if(querySettings.recursiveEnabled) {\n            query = Text.format('<View Scope=\"RecursiveAll\">{0}</View>', query);\n        }\n        else {\n            query = Text.format('<View>{0}</View>', query);\n        }\n\n        return query;\n    }\n\n    \n    /*************************************************************************************************\n     * Generates the CAML filters based on the specified array of IQueryFilter objects\n     * @param filters : The filters that needs to be converted to a CAML string\n     *************************************************************************************************/\n    private static generateFilters(filters:IQueryFilter[]): string {\n        \n        // Store the generic filter format for later use\n        let query = '';\n        let filterXml = '';\n\n        // Appends a CAML node for each filter\n        let itemCount = 0;\n\n        for(let filter of filters.reverse()) {\n            filterXml = '<{0}><FieldRef Name=\"{1}\" /><Value {2} Type=\"{3}\">{4}</Value></{0}>';\n            itemCount++;\n            let specialAttribute = '';\n\n            // Sets the special attribute if needed\n            if(filter.field.type == QueryFilterFieldType.Datetime) {\n                specialAttribute = 'IncludeTimeValue=\"' + filter.includeTime + '\"';\n            }\n\n            // If it's a <IsNull /> or <IsNotNull> filter\n            if(filter.operator == QueryFilterOperator.IsNull || filter.operator == QueryFilterOperator.IsNotNull) {\n                filterXml = '<{0}><FieldRef Name=\"{1}\" /></{0}>';\n                query += Text.format(filterXml, QueryFilterOperator[filter.operator], filter.field.internalName);\n            }\n\n            // If it's a taxonomy filter\n            else if (filter.field.type == QueryFilterFieldType.Taxonomy) {\n                query += this.generateTaxonomyFilter(filter);\n            }\n\n            // If it's a user filter\n            else if (filter.field.type == QueryFilterFieldType.User) {\n                query += this.generateUserFilter(filter);\n            }\n\n            // If it's any other kind of filter (Text, DateTime, Lookup, Number etc...)\n            else {\n                let valueType = (filter.field.type == QueryFilterFieldType.Lookup ? QueryFilterFieldType[QueryFilterFieldType.Text] : QueryFilterFieldType[filter.field.type]);\n                query += Text.format(filterXml, QueryFilterOperator[filter.operator], filter.field.internalName, specialAttribute, valueType, this.formatFilterValue(filter));\n            }\n\n            // Appends the Join tags if needed\n            if (itemCount >= 2) {\n                let logicalJoin = QueryFilterJoin[filter.join];\n                query = Text.format(\"<{0}>\", logicalJoin) + query;\n                query += Text.format(\"</{0}>\", logicalJoin);\n            }\n        }\n        \n        return query;\n    }\n\n\n    /*************************************************************************************************\n\t * Generates a valid CAML filter string based on the specified taxonomy filter\n\t * @param filter : The taxonomy filter that needs to be formatted into a CAML filter string\n\t *************************************************************************************************/\n    private static generateTaxonomyFilter(filter:IQueryFilter): string\n    {\n        let filterOutput = '';\n        let filterTerms = filter.value as ITag[];\n\n        if(isEmpty(filter.value)) {\n            return '';\n        }\n        else if (filter.operator == QueryFilterOperator.ContainsAny || filterTerms == null) {\n            let values = filterTerms != null ? filterTerms.map(x => Text.format(\"<Value Type='Integer'>{0}</Value>\", x.key)).join('') : '';\n            filterOutput = Text.format(\"<In><FieldRef Name='{0}' LookupId='TRUE' /><Values>{1}</Values></In>\", filter.field.internalName, values);\n        }\n        else if (filter.operator == QueryFilterOperator.ContainsAll) {\n            let taxFilters: IQueryFilter[] = [];\n\n            for(let term of filterTerms) {\n                let termValue:ITag[] = [ term ];\n\n                let taxFilter:IQueryFilter = {\n                    index: null,\n                    field: filter.field,\n                    value: termValue,\n                    join: QueryFilterJoin.And,\n                    operator: QueryFilterOperator.ContainsAny\n                };\n                taxFilters.push(taxFilter);\n            }\n\n            filterOutput = this.generateFilters(taxFilters);\n        }\n\n        return filterOutput;\n    }\n\n\n    /*************************************************************************************************\n\t * Generates a valid CAML filter string based on the specified user filter\n\t * @param filter : The user filter that needs to be formatted into a CAML filter string\n\t *************************************************************************************************/\n    private static generateUserFilter(filter:IQueryFilter): string\n    {\n        let filterOutput = '';\n        let filterUsers = filter.value as IPersonaProps[];\n\n        if(filter.me) {\n            filterOutput = Text.format(\"<Eq><FieldRef Name='{0}' /><Value Type='Integer'><UserID /></Value></Eq>\", filter.field.internalName);\n        }\n        else if(isEmpty(filter.value)) {\n            return '';\n        }\n        else if (filter.operator == QueryFilterOperator.ContainsAny || filterUsers == null)\n        {\n            let values = filterUsers != null ? filterUsers.map(x => Text.format(\"<Value Type='Integer'>{0}</Value>\", x.optionalText)).join('') : '';\n            filterOutput = Text.format(\"<In><FieldRef Name='{0}' LookupId='TRUE' /><Values>{1}</Values></In>\", filter.field.internalName, values);\n        }\n        else if (filter.operator == QueryFilterOperator.ContainsAll)\n        {\n            let userFilters: IQueryFilter[] = [];\n\n            for(let user of filterUsers) {\n                let userValue:IPersonaProps[] = [ user ];\n\n                let userFilter:IQueryFilter = {\n                    index: null,\n                    field: filter.field,\n                    value: userValue,\n                    join: QueryFilterJoin.And,\n                    operator: QueryFilterOperator.ContainsAny\n                };\n                userFilters.push(userFilter);\n            }\n\n            filterOutput = this.generateFilters(userFilters);\n        }\n\n        return filterOutput;\n    }\n\n\n\t/*************************************************************************************************\n\t * Returns the value of the specified filter correctly formatted based on its type of value\n\t * @param filter : The filter that needs its value to be formatted\n\t *************************************************************************************************/\n    private static formatFilterValue(filter:IQueryFilter): string\n    {\n        let filterValue = \"\";\n\n        if(filter.field.type == QueryFilterFieldType.Datetime) {\n            if(filter.expression != null && !isEmpty(filter.expression)) {\n                filterValue = this.formatDateExpressionFilterValue(filter.expression);\n            }\n            else {\n                filterValue = this.formatDateFilterValue(filter.value as string);\n            }\n        }\n        else {\n            filterValue = this.formatTextFilterValue(filter.value as string);\n        }\n\n        return filterValue;\n    }\n\n\n    /*************************************************************************************************\n     * Converts the specified serialized ISO date into the required string format\n     * @param dateValue : A valid ISO 8601 date string\n     *************************************************************************************************/\n    private static formatDateFilterValue(dateValue:string): string {\n        let date = moment(dateValue, moment.ISO_8601, true);\n\n        if(date.isValid()) {\n            dateValue = date.format(\"YYYY-MM-DDTHH:mm:ss\\\\Z\");\n        }\n        return dateValue || '';\n    }\n\n\n    /*************************************************************************************************\n     * Replaces any \"[Today]\" or \"[Today] +/- [digit]\" expression by it's actual value\n     * @param filterValue : The filter value\n     *************************************************************************************************/\n    private static formatDateExpressionFilterValue(filterValue: string): string {\n\t\t\n\t\t// Replaces any \"[Today] +/- [digit]\" expression\n        let regex = new RegExp(\"\\\\[Today\\\\]\\\\s*[\\\\+-]\\\\s*\\\\[{0,1}\\\\d{1,}\\\\]{0,1}\");\n\t\tlet results = regex.exec(filterValue);\n\n        if(results != null) {\n            for(let result of results) {\n                let operator = result.indexOf('+') > 0 ? '+' : '-';\n                let addOrRemove = operator == '+' ? 1 : -1;\n                let operatorSplit = result.split(operator);\n                let digit = parseInt(operatorSplit[operatorSplit.length - 1].replace(\"[\", \"\").replace(\"]\", \"\").trim()) * addOrRemove;\n                let dt = new Date();\n                dt.setDate(dt.getDate() + digit);\n                let formatDate = moment(dt).format(\"YYYY-MM-DDTHH:mm:ss\\\\Z\");\n                filterValue = filterValue.replace(result, formatDate);\n            }\n        }\n\n\t\t// Replaces any \"[Today]\" expression by it's actual value\n        let formattedDate = moment(new Date()).format(\"YYYY-MM-DDTHH:mm:ss\\\\Z\");\n        filterValue = filterValue.replace(\"[Today]\", formattedDate);\n\n        return filterValue;\n    }\n\n\n    /*************************************************************************************************\n     * Formats the specified text filter value\n     * @param textValue : The text filter value which needs to be formatted\n     *************************************************************************************************/\n    private static formatTextFilterValue(textValue:string): string {\n        let regex = new RegExp(\"\\\\[PageQueryString:[A-Za-z0-9_-]*\\\\]\");\n        let results = regex.exec(textValue);\n\n        if(results != null) {\n            for(let result of results) {\n                let parameter = result.substring(17, result.length - 1);\n                textValue = textValue.replace(result, this.getUrlParameter(parameter));\n            }\n        }\n        \n        return textValue != null ? textValue : '';\n    }\n\n\n    /*************************************************************************************************\n     * Returns the value of the query string parameter with the specified name\n     * @param name : The name of the query string parameter\n     * @param url : Optionnaly, the specific url to use instead of the current url\n     *************************************************************************************************/\n    private static getUrlParameter(name: string, url?: string): string {\n        if (!url) {\n            url = window.location.href;\n        }\n        name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n        var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n            results = regex.exec(url);\n        if (!results) return null;\n        if (!results[2]) return '';\n        return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n    }\n\n}\n"],"sourceRoot":"..\\..\\..\\src"}